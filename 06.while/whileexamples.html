<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>6.5. While Examples &mdash; Introduction to Computer Science in C# 23 Jul 2024 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6.6. More String Methods" href="stringmethods2.html" />
    <link rel="prev" title="6.4. Short-Circuiting &amp;&amp; and ||" href="condition-short-circuit.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Introduction to Computer Science in C#
          </a>
              <div class="version">
                23 Jul 2024
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../01.context/context.html">1. 1.Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../02.data/data.html">2. Data and Operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03.functions/functions.html">3. Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04.basicstringops/basicstringops.html">4. Strings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05.decisions/decisions.html">5. Decisions</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="while.html">6. While Loops</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="whilestatements.html">6.1. While-Statements</a></li>
<li class="toctree-l2"><a class="reference internal" href="while-with-sequence.html">6.2. While-Statements with Sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="whileinteractive.html">6.3. Interactive <code class="docutils literal notranslate"><span class="pre">while</span></code> Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="condition-short-circuit.html">6.4. Short-Circuiting &amp;&amp; and ||</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">6.5. While Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="stringmethods2.html">6.6. More String Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="userinput.html">6.7. User Input: UI</a></li>
<li class="toctree-l2"><a class="reference internal" href="gcdexamples.html">6.8. Greatest Common Divisor</a></li>
<li class="toctree-l2"><a class="reference internal" href="do-while.html">6.9. Do-While Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab-number-game.html">6.10. Number Guessing Game Lab</a></li>
<li class="toctree-l2"><a class="reference internal" href="reviewwhile.html">6.11. Chapter Review Questions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../07.foreach/foreach.html">7. foreach Loops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../08.for/for.html">8. for Loops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../09.files/files.html">9. Files, Paths, and Directories</a></li>
<li class="toctree-l1"><a class="reference internal" href="../10.arrays/arrays.html">10. Arrays</a></li>
<li class="toctree-l1"><a class="reference internal" href="../11.lists/lists.html">11. Lists</a></li>
<li class="toctree-l1"><a class="reference internal" href="../12.dictionaries/dictionaries.html">12. Dictionaries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../13.classes/classes.html">13. Object-Oriented Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../14.testing/testing.html">14. Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../15.interfaces/interfaces.html">15. Interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../16.recursion/recursion.html">16. Recursion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../17.datastructures/datastructures.html">17. Data Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../18.appendix/appendix.html">18. Appendix</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Introduction to Computer Science in C#</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="while.html"><span class="section-number">6. </span>While Loops</a></li>
      <li class="breadcrumb-item active"><span class="section-number">6.5. </span>While Examples</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/06.while/whileexamples.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="while-examples">
<h1><span class="section-number">6.5. </span>While Examples<a class="headerlink" href="#while-examples" title="Permalink to this heading"></a></h1>
<section id="bisection-method">
<span id="index-0"></span><span id="id1"></span><h2><span class="section-number">6.5.1. </span>Bisection Method<a class="headerlink" href="#bisection-method" title="Permalink to this heading"></a></h2>
<p>For a very different example we look to scientific computing.  In math
class you likely learned various ways to find roots of functions f(x) exactly.
In practice those methods almost never work beyond low order polynomials.
Hence the best we can do usually is to approximate solutions numerically.
One broadly useful approach is the <em>bisection method</em>.  You just need a
continuous function (with an unbroken graph),
and you need to first find two places,
a and b, where f(a) and f(b) have opposite signs. If f is continuous and goes
between positive and negative values, then it must cross 0 somewhere in between,
and so there must be a real solution.  The question is how to get close
to a crossing point efficiently.</p>
<p>As an example we show <span class="math notranslate nohighlight">\(f(x)=x^2 - 2\)</span>, in the range from x = 0 to x = 2.
As a first example we choose a simple function where the root can be figured symbolically,
in this case the square root of 2.  The figure below shows the graph,
with extra horizontal and vertical lines that will will be explained.</p>
<a class="reference internal image-reference" href="../_images/bisection.png"><img alt="../_images/bisection.png" src="../_images/bisection.png" style="width: 200pt;" /></a>
<p>In the figure a= 0, f(0) &lt; 0, b = 2, f(2) &gt; 0.</p>
<p>The basic idea is to bisect the interval between a and b, finding the midpoint,
c = (a+b)/2. If f(c) is 0, you are done.
Otherwise f(c) has a sign which must be opposite <em>one</em> of f(a) and f(b).</p>
<p>In the figure the initial interval has the same x coordinates as for the top gray line.
Its midpoint is at 1, the x coordinate of the red vertical segment coming down from
the top gray line in the figure.  Note f(1) &lt; 0, the opposite sign of f(2),
so we next consider the half of the original interval from the midpoint 1 to 2,
with the next gray line marking this interval.
The function still must cross 0 in the smaller interval because of the opposite
signs for f on the endpoints.  In
the iterative procedure, you  continue this process, halving the length of
the interval,
shifting one endpoint or the other to be the middle
of the most recent interval, so for each interval, the signs of f on
the two ends are opposite.
Repeating this procedure, you can home in on as small an interval around a
crossing point (root) as you like.
The figure show this process for the first 5 steps,
halving the interval length each time.  You need to look at the output of the code to
follow the results for even smaller intervals.</p>
<p>This approach always works, as long as the signs of f
at the initial endpoints are distinct.  Our <code class="docutils literal notranslate"><span class="pre">Bisection</span></code> functions check,
and if this initial requirement
is violated, the function returns the special double code value,
<code class="docutils literal notranslate"><span class="pre">double.NaN</span></code>, meaning <em>not a number</em>.</p>
<p>There are other approaches to finding roots that may be faster when they work,
but many of these methods can also have some chance of completely failing,
so root finding algorithms generally have two
extra parameters:  a maximum number of iterations and a tolerance that
indicates how close to a root is close enough.</p>
<p>In the <code class="docutils literal notranslate"><span class="pre">Bisection</span></code> function we use <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>
as the endpoints of an interval and <code class="docutils literal notranslate"><span class="pre">c</span></code> as the
midpoint.  In each iteration the value of <code class="docutils literal notranslate"><span class="pre">a</span></code> or <code class="docutils literal notranslate"><span class="pre">b</span></code> is reset to be the
previous midpoint value <code class="docutils literal notranslate"><span class="pre">c</span></code>.
Of course a production version would not print out all the intermediate data,
as the interval shrinks, but we do for illustration:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">Bisection</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">b</span><span class="p">,</span>
<span class="w">                               </span><span class="kt">double</span><span class="w"> </span><span class="n">tolerance</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">iterations</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="c1">// check the preconditions for the method to work</span>
<span class="w">   </span><span class="c1">// a must be less than b so we can do the interval search</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">&gt;=</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="kt">double</span><span class="p">.</span><span class="n">NaN</span><span class="p">;</span>
<span class="w">   </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;a &gt;= b ok&quot;</span><span class="p">);</span>
<span class="w">   </span><span class="kt">bool</span><span class="w"> </span><span class="n">ok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">false</span><span class="p">;</span>

<span class="w">   </span><span class="c1">// The function must cross the x-axis between the endpoints,</span>
<span class="w">   </span><span class="c1">//   meaning its sign changes.</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">0</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;Test 1 passed&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="n">ok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">true</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">((</span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="m">0</span><span class="p">))</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;Test 2 passed&quot;</span><span class="p">);</span>
<span class="w">      </span><span class="n">ok</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="k">true</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="o">!</span><span class="n">ok</span><span class="p">)</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="kt">double</span><span class="p">.</span><span class="n">NaN</span><span class="p">;</span>
<span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="o">=</span><span class="m">0</span><span class="p">;</span>
<span class="w">   </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">n</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">iterations</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kt">double</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="m">2</span><span class="p">;</span>
<span class="w">      </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;a = {0}  b={1}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="o">||</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="o">/</span><span class="m">2</span><span class="w"> </span><span class="o">&lt;</span><span class="w"> </span><span class="n">tolerance</span><span class="p">)</span>
<span class="w">         </span><span class="k">return</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Math</span><span class="p">.</span><span class="n">Sign</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">c</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="n">Sign</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>
<span class="w">         </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">      </span><span class="k">else</span>
<span class="w">         </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">      </span><span class="n">n</span><span class="o">++</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="kt">double</span><span class="p">.</span><span class="n">NaN</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Since the bisection method always homes in on a real root rapidly,
an alternate version specifically for the bisection method
finds the <em>best</em> approximation possible with <code class="docutils literal notranslate"><span class="pre">double</span></code>
arithmetic.  While you can always halve an interval mathematically, you
eventually run out of distinct <code class="docutils literal notranslate"><span class="pre">double</span></code> values! We can stop when
the midpoint (calculated with limited <code class="docutils literal notranslate"><span class="pre">double</span></code> precision)
is <em>exactly</em> the same as <code class="docutils literal notranslate"><span class="pre">a</span></code> or <code class="docutils literal notranslate"><span class="pre">b</span></code>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">/// This bisection method returns the best double approximation</span>
<span class="c1">/// to a root of f.  Returns double.NaN if the f(a)*f(b) &gt; 0.</span>
<span class="c1">/// Does not require a &lt; b.</span>
<span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">Bisection</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Math</span><span class="p">.</span><span class="n">Sign</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">b</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="n">Sign</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span><span class="w">  </span><span class="c1">//or f(a)*f(b)&gt;0</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="kt">double</span><span class="p">.</span><span class="n">NaN</span><span class="p">;</span>
<span class="w">   </span><span class="kt">double</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="m">2</span><span class="p">;</span>
<span class="w">   </span><span class="c1">// If no f(c) is exactly 0, iterate until the smallest possible</span>
<span class="w">   </span><span class="c1">// double interval, when there is no distinct double midpoint.</span>
<span class="w">   </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">c</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">c</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="n">Console</span><span class="p">.</span><span class="n">WriteLine</span><span class="w"> </span><span class="p">(</span><span class="s">&quot;a = {0}  b= {1}, diff = {2}&quot;</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="o">-</span><span class="n">a</span><span class="p">);</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">c</span><span class="p">)</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="p">)</span>
<span class="w">         </span><span class="k">return</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">Math</span><span class="p">.</span><span class="n">Sign</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">c</span><span class="p">))</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="n">Sign</span><span class="p">(</span><span class="n">f</span><span class="p">(</span><span class="n">a</span><span class="p">)))</span>
<span class="w">         </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">      </span><span class="k">else</span>
<span class="w">         </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="w">      </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">/</span><span class="w"> </span><span class="m">2</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>C# remembers <code class="docutils literal notranslate"><span class="pre">double</span></code> values to more decimal places than it will actually
display, so the second illustration also shows the difference between <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>,
indicating the double values are still not really equal even after their
displays match.</p>
<p>You can try this full example,
<a class="reference external" href="https://github.com/tychen742/introcs-csharp-examples/blob/master/bisection_method1/bisection_method1.cs">bisection_method1/bisection_method1.cs</a>.
Note the special function checking for <code class="docutils literal notranslate"><span class="pre">double.NaN</span></code> in <code class="docutils literal notranslate"><span class="pre">Main</span></code>,
because <code class="docutils literal notranslate"><span class="pre">double.NaN</span></code> is not equal to itself!</p>
<p>The current versions have a major limitation:  They just work with the one
canned version of the function <code class="docutils literal notranslate"><span class="pre">f</span></code> in the class.
You need to edit
the source code to use the same process with a different function!
There are several ways around this using more advanced C# features.
After the section <a class="reference internal" href="../15.interfaces/interfaces.html#interface"><span class="std std-ref">Interfaces</span></a>, a more flexible version
should make sense, <a class="reference external" href="https://github.com/tychen742/introcs-csharp-examples/blob/master/bisection_method/bisection_method.cs">bisection_method/bisection_method.cs</a>,
explored further in <a class="reference internal" href="../15.interfaces/csproj-revisited.html#bisection-exercise"><span class="std std-ref">Bisection With Function Interface Exercise</span></a>.  The more
advanced version illustrates with the function in the initial version and
several others, all using the same bisection function.</p>
</section>
<section id="savings-exercise">
<span id="index-1"></span><span id="id2"></span><h2><span class="section-number">6.5.2. </span>Savings Exercise<a class="headerlink" href="#savings-exercise" title="Permalink to this heading"></a></h2>
<p>The idea here is to see how many years it will take a bank account to grow
to at least a given value, assuming a fixed annual interest.
Write a program <code class="docutils literal notranslate"><span class="pre">savings.cs</span></code>.
Prompts the user for three numbers: an initial balance, the annual percentage
for interest as a decimal. like .04 for 4%, and the final balance desired.
Print the initial balance, and the balance each year until
the desired amount is reached. Round displayed amounts
to two decimal places, as usual.</p>
<p>The math:  The amount next year is the amount now times
(1 + interest fraction),
so if I have $500 now and the interest rate is .04,
I have $500*(1.04) = $520 after one year, and after two years I have,
$520*(1.04) = $540.80.
If I enter into the program a $500 starting balance, .04 interest rate and
a target of $550, the program prints:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="m">500.00</span>
<span class="m">520.00</span>
<span class="m">540.80</span>
<span class="m">563.42</span>
</pre></div>
</div>
</section>
<section id="strange-sequence-exercise">
<span id="strange-seq-ex"></span><span id="index-2"></span><h2><span class="section-number">6.5.3. </span>Strange Sequence Exercise<a class="headerlink" href="#strange-sequence-exercise" title="Permalink to this heading"></a></h2>
<p>Save the example program <a class="reference external" href="https://github.com/tychen742/introcs-csharp-examples/blob/master/strange_seq_stub/strange_seq.cs">strange_seq_stub/strange_seq.cs</a>
in a project of your own.</p>
<p>There are three functions to complete.  Do one at a time and test.</p>
<p><code class="docutils literal notranslate"><span class="pre">Jump</span></code>: First complete the definitions of function <code class="docutils literal notranslate"><span class="pre">Jump</span></code>.
For any integer <code class="docutils literal notranslate"><span class="pre">n</span></code>, <code class="docutils literal notranslate"><span class="pre">Jump(n)</span></code> is <code class="docutils literal notranslate"><span class="pre">n/2</span></code> if <code class="docutils literal notranslate"><span class="pre">n</span></code> is even,
and <code class="docutils literal notranslate"><span class="pre">3*n+1</span></code> if <code class="docutils literal notranslate"><span class="pre">n</span></code> is odd.
In the <code class="docutils literal notranslate"><span class="pre">Jump</span></code> function definition use an <code class="docutils literal notranslate"><span class="pre">if</span></code>-<code class="docutils literal notranslate"><span class="pre">else</span></code>
statement.  Hint <a class="footnote-reference brackets" href="#oddeven" id="id3" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p>
<p><code class="docutils literal notranslate"><span class="pre">PrintStrangeSequence</span></code>:
You can start with one number, say n = 3, and <em>keep</em> applying the
<code class="docutils literal notranslate"><span class="pre">Jump</span></code> function to the <em>last</em> number given,
and see how the numbers jump around!</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">Jump</span><span class="p">(</span><span class="m">3</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">3</span><span class="o">*</span><span class="m">3</span><span class="o">+</span><span class="m">1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">10</span><span class="p">;</span><span class="w"> </span><span class="n">Jump</span><span class="p">(</span><span class="m">10</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">10</span><span class="o">/</span><span class="m">2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">5</span><span class="p">;</span>
<span class="n">Jump</span><span class="p">(</span><span class="m">5</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">3</span><span class="o">*</span><span class="m">5</span><span class="o">+</span><span class="m">1</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">16</span><span class="p">;</span><span class="w"> </span><span class="n">Jump</span><span class="p">(</span><span class="m">16</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">16</span><span class="o">/</span><span class="m">2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">8</span><span class="p">;</span>
<span class="n">Jump</span><span class="p">(</span><span class="m">8</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">8</span><span class="o">/</span><span class="m">2</span><span class="w">  </span><span class="o">=</span><span class="w">   </span><span class="m">4</span><span class="p">;</span><span class="w"> </span><span class="n">Jump</span><span class="p">(</span><span class="m">4</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w">   </span><span class="m">4</span><span class="o">/</span><span class="m">2</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2</span><span class="p">;</span>
<span class="n">Jump</span><span class="p">(</span><span class="m">2</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">2</span><span class="o">/</span><span class="m">2</span><span class="w">  </span><span class="o">=</span><span class="w">   </span><span class="m">1</span>
</pre></div>
</div>
<p>This process of repeatedly applying the same function to the most recent result
is called function <em>iteration</em>.  In this case you see that iterating the
<code class="docutils literal notranslate"><span class="pre">Jump</span></code> function, starting from n=3, eventually reaches the value 1.</p>
<p>It is an <em>open research question</em> whether iterating the Jump function
from an integer <code class="docutils literal notranslate"><span class="pre">n</span></code> will eventually reach 1,
for <em>every</em> starting integer <code class="docutils literal notranslate"><span class="pre">n</span></code> greater than 1.
Researchers have only found examples of <code class="docutils literal notranslate"><span class="pre">n</span></code> where it is true.
Still, no general argument has been made to apply to the
<em>infinite</em> number of possible starting integers.</p>
<p>In the PrintStrangeSequence you iterate the <code class="docutils literal notranslate"><span class="pre">Jump</span></code> function
starting from parameter value <code class="docutils literal notranslate"><span class="pre">n</span></code>, as long as the current number is not 1.
If you start with 1, stop immediately.</p>
<p><code class="docutils literal notranslate"><span class="pre">CountStrangeSequence</span></code>:  Iterate the <code class="docutils literal notranslate"><span class="pre">Jump</span></code> function as in
<code class="docutils literal notranslate"><span class="pre">PrintStrangeSequence</span></code>.  Instead of printing each number in the sequence,
just count them, and return the count.</p>
</section>
<section id="roundoff-exercise-ii">
<span id="roundoff2"></span><span id="index-3"></span><h2><span class="section-number">6.5.4. </span>Roundoff Exercise II<a class="headerlink" href="#roundoff-exercise-ii" title="Permalink to this heading"></a></h2>
<p>Write a program to complete and test the function with this heading
and documentation:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Return the largest possible number y, so in C#: x+y = x</span>
<span class="c1">/// If x is Infinity return Infinity.</span>
<span class="c1">/// If x is -Infinity, return double.MaxValue.</span>
<span class="c1">/// Assume x is not NaN (which is equal to nothing).</span>
<span class="k">static</span><span class="w"> </span><span class="kt">double</span><span class="w"> </span><span class="nf">Epsilon</span><span class="p">(</span><span class="kt">double</span><span class="w"> </span><span class="n">x</span><span class="p">)</span>
</pre></div>
</div>
<p>Hint:  The non-exceptional case can have some similarity
to the bisection in the best root approximation example:
start with two endpoints, <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>, where <code class="docutils literal notranslate"><span class="pre">x+a</span> <span class="pre">=</span> <span class="pre">x</span></code> and
<code class="docutils literal notranslate"><span class="pre">x+b</span> <span class="pre">&gt;</span> <span class="pre">x</span></code>, and reduce the interval size by half….</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="oddeven" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id3">1</a><span class="fn-bracket">]</span></span>
<p>If you divide an even number by 2, what is the remainder?  Use this idea
in your <code class="docutils literal notranslate"><span class="pre">if</span></code> condition.</p>
</aside>
</aside>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="condition-short-circuit.html" class="btn btn-neutral float-left" title="6.4. Short-Circuiting &amp;&amp; and ||" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="stringmethods2.html" class="btn btn-neutral float-right" title="6.6. More String Methods" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright .
      <span class="lastupdated">Last updated on 23-July-2024 07:59:52.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>