<!DOCTYPE html>
<html class="writer-html5" lang="en">
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.19: https://docutils.sourceforge.io/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>6.8. Greatest Common Divisor &mdash; Introduction to Computer Science in C# 22 Jul 2024 documentation</title>
      <link rel="stylesheet" type="text/css" href="../_static/pygments.css" />
      <link rel="stylesheet" type="text/css" href="../_static/css/theme.css" />

  
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/_sphinx_javascript_frameworks_compat.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/sphinx_highlight.js"></script>
        <script async="async" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="6.9. Do-While Loops" href="do-while.html" />
    <link rel="prev" title="6.7. User Input: UI" href="userinput.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Introduction to Computer Science in C#
          </a>
              <div class="version">
                22 Jul 2024
              </div>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../01.context/context.html">1. 1.Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../02.data/data.html">2. Data and Operations</a></li>
<li class="toctree-l1"><a class="reference internal" href="../03.functions/functions.html">3. Functions</a></li>
<li class="toctree-l1"><a class="reference internal" href="../04.basicstringops/basicstringops.html">4. Strings</a></li>
<li class="toctree-l1"><a class="reference internal" href="../05.decisions/decisions.html">5. Decisions</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="while.html">6. While Loops</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="whilestatements.html">6.1. While-Statements</a></li>
<li class="toctree-l2"><a class="reference internal" href="while-with-sequence.html">6.2. While-Statements with Sequences</a></li>
<li class="toctree-l2"><a class="reference internal" href="whileinteractive.html">6.3. Interactive <code class="docutils literal notranslate"><span class="pre">while</span></code> Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="condition-short-circuit.html">6.4. Short-Circuiting &amp;&amp; and ||</a></li>
<li class="toctree-l2"><a class="reference internal" href="whileexamples.html">6.5. While Examples</a></li>
<li class="toctree-l2"><a class="reference internal" href="stringmethods2.html">6.6. More String Methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="userinput.html">6.7. User Input: UI</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">6.8. Greatest Common Divisor</a></li>
<li class="toctree-l2"><a class="reference internal" href="do-while.html">6.9. Do-While Loops</a></li>
<li class="toctree-l2"><a class="reference internal" href="lab-number-game.html">6.10. Number Guessing Game Lab</a></li>
<li class="toctree-l2"><a class="reference internal" href="reviewwhile.html">6.11. Chapter Review Questions</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../07.foreach/foreach.html">7. foreach Loops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../08.for/for.html">8. for Loops</a></li>
<li class="toctree-l1"><a class="reference internal" href="../09.files/files.html">9. Files, Paths, and Directories</a></li>
<li class="toctree-l1"><a class="reference internal" href="../10.arrays/arrays.html">10. Arrays</a></li>
<li class="toctree-l1"><a class="reference internal" href="../11.lists/lists.html">11. Lists</a></li>
<li class="toctree-l1"><a class="reference internal" href="../12.dictionaries/dictionaries.html">12. Dictionaries</a></li>
<li class="toctree-l1"><a class="reference internal" href="../13.classes/classes.html">13. Object-Oriented Programming</a></li>
<li class="toctree-l1"><a class="reference internal" href="../14.testing/testing.html">14. Testing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../15.interfaces/interfaces.html">15. Interfaces</a></li>
<li class="toctree-l1"><a class="reference internal" href="../16.recursion/recursion.html">16. Recursion</a></li>
<li class="toctree-l1"><a class="reference internal" href="../17.datastructures/datastructures.html">17. Data Structures</a></li>
<li class="toctree-l1"><a class="reference internal" href="../18.appendix/appendix.html">18. Appendix</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Introduction to Computer Science in C#</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content style-external-links">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="while.html"><span class="section-number">6. </span>While Loops</a></li>
      <li class="breadcrumb-item active"><span class="section-number">6.8. </span>Greatest Common Divisor</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/06.while/gcdexamples.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="greatest-common-divisor">
<span id="gcd"></span><span id="index-0"></span><h1><span class="section-number">6.8. </span>Greatest Common Divisor<a class="headerlink" href="#greatest-common-divisor" title="Permalink to this heading"></a></h1>
<section id="euclid-s-algorithm">
<h2><span class="section-number">6.8.1. </span>Euclid’s Algorithm<a class="headerlink" href="#euclid-s-algorithm" title="Permalink to this heading"></a></h2>
<p>The greatest common divisor of two non-zero integers is a great
example to illustrate the power of loops. Everyone learns about the
<em>concept</em> of a greatest common divisor when faced with a fraction that
is not in <em>reduced</em> form.</p>
<p>Consider the fraction <span class="math notranslate nohighlight">\(\frac{2}{4}\)</span>, which is the same as
<span class="math notranslate nohighlight">\(\frac{1}{2}\)</span>. The fraction <span class="math notranslate nohighlight">\(\frac{2}{4}\)</span>
can be reduced, because the
numerator and denominator both have greatest common factor of 2. That
is, <span class="math notranslate nohighlight">\(\frac{2}{4} = \frac{1 \cdot 2}{2 \cdot 2}\)</span>. So the factor of 2 can
be canceled from both the numerator and the denominator.</p>
<p>Euclid (the mathematician from classic times and author of <em>Elements</em>)
is credited with having come up with a clever algorithm for how to
compute the greatest common divisor efficiently. It is written as
follows, where <span class="math notranslate nohighlight">\(a \bmod b\)</span> means <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">%</span> <span class="pre">b</span></code> in C#.</p>
<div class="math notranslate nohighlight">
\[ \begin{align}\begin{aligned}gcd(a, b) = gcd(b, a \bmod b)\\gcd(a, 0) = a\end{aligned}\end{align} \]</div>
<p>It is common in mathematics to list functions as one or more
<em>cases</em>. The way you read this is as follows:</p>
<ul class="simple">
<li><p>In general, the greatest common divisor of <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> is the
same as computing the greatest common divisor of <code class="docutils literal notranslate"><span class="pre">b</span></code> and the
remainder of <code class="docutils literal notranslate"><span class="pre">a</span></code> divided by <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p></li>
<li><p>In the case where <code class="docutils literal notranslate"><span class="pre">b</span></code> is zero, the result is <code class="docutils literal notranslate"><span class="pre">a</span></code>. This makes
sense because <code class="docutils literal notranslate"><span class="pre">a</span></code> divides itself and 0.</p></li>
</ul>
<p>To gain some appreciation of how the definition <em>always</em> allows you to
compute the greatest common divisor, it is worthwhile to try it out
for a couple of numbers where you <em>know</em> the greatest common
divisor. For example, we already know that the greatest common divisor
of 10 and 15 is 5. Let’s use Euclid’s method to verify this:</p>
<ul class="simple">
<li><p><span class="math notranslate nohighlight">\(gcd(10, 15) = gcd(15, 10 \bmod 15) = gcd(15, 10)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(gcd(15, 10) = gcd(10, 15 \bmod 10) = gcd(10, 5)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(gcd(10, 5) = gcd(5, 10 \bmod 5) = gcd(5, 0)\)</span></p></li>
<li><p><span class="math notranslate nohighlight">\(gcd(5, 0) = 5\)</span></p></li>
</ul>
<p>Notice that in the example above, the first number (10) was smaller than
the second (15), and the first transformation just swapped the numbers,
so the larger number was first.  Thereafter the first number is always
larger.</p>
</section>
<section id="gcd-brute-force-method">
<h2><span class="section-number">6.8.2. </span>GCD “Brute Force” Method<a class="headerlink" href="#gcd-brute-force-method" title="Permalink to this heading"></a></h2>
<p>Now that we’ve gotten the preliminaries out of the way and have a basic
mathematical explanation for how
to calculate the greatest common divisor,
we’ll take a look at how to translate this into code using the
machinery of while loops that you’ve recently learned.</p>
<p>The way GCD is formulated above is, indeed, the most clever way to
calculate the greatest common divisor.
Yet the way we learn about the greatest common divisor in elementary
school (at least at first) is to
learn how to factor the numbers a and b, often in a brute force way.
So for example, when calculating the
greatest common divisor of 10 and 15, we can immediately see it,
because we know that both of these
numbers are divisible by 5 (e.g. 5 * 2 = 10 and 5 * 3 = 15).
So the greatest common divisor is 5.</p>
<p>But if we had something more tricky to do like 810 and 729,
we might have to think a bit more.</p>
<p>Before we learn to find the factors of numbers,
we will often just “try” numbers until we get the
greatest common divisor. This sort of trial process can take place in a loop,
where we start at 1 and end at min(a, b). Why the minimum?
We know that none of the values after the minimum can divide both a and b
(in integer division),
because no larger number can divide a smaller positive number. The smaller
number would be the (non-zero) remainder.</p>
<p>Now take a look at a basic version of GCD:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="c1">/// Return the greatest common divisor of positive numbers.</span>
<span class="linenos"> 2</span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">GreatestCommonDivisor</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="linenos"> 3</span><span class="p">{</span>
<span class="linenos"> 4</span><span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">n</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">Math</span><span class="p">.</span><span class="n">Min</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">);</span>
<span class="linenos"> 5</span><span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">gcd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="m">1</span><span class="p">;</span>
<span class="linenos"> 6</span>
<span class="linenos"> 7</span><span class="w">   </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">i</span><span class="w"> </span><span class="o">&lt;=</span><span class="w"> </span><span class="n">n</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 8</span><span class="w">      </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="w"> </span><span class="o">&amp;&amp;</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 9</span><span class="w">         </span><span class="n">gcd</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">i</span><span class="p">;</span>
<span class="linenos">10</span><span class="w">      </span><span class="p">}</span>
<span class="linenos">11</span><span class="w">      </span><span class="n">i</span><span class="o">++</span><span class="p">;</span>
<span class="linenos">12</span><span class="w">   </span><span class="p">}</span>
<span class="linenos">13</span><span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">gcd</span><span class="p">;</span>
<span class="linenos">14</span><span class="p">}</span>
</pre></div>
</div>
<p>This code works as follows:</p>
<ul class="simple">
<li><p>We begin by finding <code class="docutils literal notranslate"><span class="pre">Math.Min(a,</span> <span class="pre">b)</span></code>.
This is how to compute the minimum of any two
values in C#. Technically, we don’t need to use the minimum of a and b,
but there is no
point in doing any more work than necessary.</p></li>
<li><p>We’ll use the variable <code class="docutils literal notranslate"><span class="pre">i</span></code> as the loop index, starting at 1.</p></li>
<li><p>The variable <code class="docutils literal notranslate"><span class="pre">gcd</span></code> will hold the largest currently known common divisor.
We start with 1, which divides any integer, and we will
look for a higher value that also divides a and b.</p></li>
<li><p>The line <code class="docutils literal notranslate"><span class="pre">while</span> <span class="pre">(i</span> <span class="pre">&lt;=</span> <span class="pre">n)</span></code> is used to indicate that we are
iterating the values of
<code class="docutils literal notranslate"><span class="pre">i</span></code> until the minimum of <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> (computed earlier) is reached.</p></li>
<li><p>The line <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(a</span> <span class="pre">%</span> <span class="pre">i</span> <span class="pre">==</span> <span class="pre">0</span> <span class="pre">&amp;&amp;</span> <span class="pre">b</span> <span class="pre">%</span> <span class="pre">i</span> <span class="pre">==</span> <span class="pre">0)</span></code>
is used to check whether we have found a
new value that replaces our previous <em>candidate</em> for the GCD.
A value can only be
a candidate for the GCD if it divides a and b without a remainder.
The modulus
operator <code class="docutils literal notranslate"><span class="pre">%</span></code> is our way of determining whether there is a
remainder from the
division operation <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">/</span> <span class="pre">i</span></code> or <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">/</span> <span class="pre">i</span></code>.</p></li>
<li><p>The line <code class="docutils literal notranslate"><span class="pre">i++</span></code> is our way of going to the next value of <code class="docutils literal notranslate"><span class="pre">i</span></code>
to be tested as the new GCD.</p></li>
<li><p>When this loop terminates, the greatest common divisor has been found.</p></li>
</ul>
<p>So this gives you a relatively straightforward way of calculating the
greatest common divisor. While simple, it is not necessarily the most
efficient way of determining the GCD. If you think about what is going on,
this loop could run a significant number of times.
For example, if you were calculating the GCD two very large numbers, say,
one billion (1,000,000,000) and two billion (2,000,000,000)
it is painfully evident that you would consider a large number of values
(a billion, in fact) before obtaining
the candidate GCD, which we know is 1,000,000,000.</p>
<section id="brute-force-gcd-exercise">
<h3><span class="section-number">6.8.2.1. </span>Brute-Force GCD Exercise<a class="headerlink" href="#brute-force-gcd-exercise" title="Permalink to this heading"></a></h3>
<p>The code above goes though all integers 2 through <code class="docutils literal notranslate"><span class="pre">min(a,</span> <span class="pre">b)</span></code>.  That is
not generally necessary when the GCD is greater than 1,
even with a brute-force mindset.   Write a
<code class="docutils literal notranslate"><span class="pre">g_c_d_basic_faster.cs</span></code> to do this with a slightly different
<code class="docutils literal notranslate"><span class="pre">GreatestCommonDivisor</span></code> function. <a class="footnote-reference brackets" href="#gcdbrute" id="id1" role="doc-noteref"><span class="fn-bracket">[</span>1<span class="fn-bracket">]</span></a></p>
</section>
</section>
<section id="gcd-subtraction-method">
<h2><span class="section-number">6.8.3. </span>GCD Subtraction Method<a class="headerlink" href="#gcd-subtraction-method" title="Permalink to this heading"></a></h2>
<p>The subtraction method (also attributable to Euclid) to compute the
Greatest Common Divisor works as follows:</p>
<ul class="simple">
<li><p>Based on the <em>mathematical</em> definition in the previous section, the
greatest common divisor algorithm saves a step when we already have
<code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> in the <em>right order</em>.</p></li>
<li><p>The <em>right order</em> means that <span class="math notranslate nohighlight">\(a &gt; b\)</span>. As we noted earlier, the
cleverness of the <em>mathematical</em> definition is that <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>
are swapped as the first step to ensure that <span class="math notranslate nohighlight">\(a &gt; b\)</span>, after
which we can repeatedly divide to get the GCD.</p></li>
<li><p>Division, of course, is a form of repetitive subtraction, so the way
to divide by <code class="docutils literal notranslate"><span class="pre">b</span></code> is to repeatedly subtract it (from a) until <code class="docutils literal notranslate"><span class="pre">a</span></code>
is no longer greater than <code class="docutils literal notranslate"><span class="pre">b</span></code>.</p></li>
<li><p>The subtraction method basically makes no attempt to put <code class="docutils literal notranslate"><span class="pre">a</span></code> and
<code class="docutils literal notranslate"><span class="pre">b</span></code> in the right order. Instead, we just write similar loops to
allow for the possibility of either order.</p></li>
<li><p>A simple check must be performed to ensure that the approach of
repeated subtraction actually resulted in the GCD. This will happen
if <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> bump into one another, thereby meaning that we
have computed the GCD.</p></li>
</ul>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="linenos"> 1</span><span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">GreatestCommonDivisor</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="linenos"> 2</span><span class="p">{</span>
<span class="linenos"> 3</span><span class="w">   </span><span class="kt">int</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="linenos"> 4</span><span class="w">   </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 5</span><span class="w">      </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">a</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos"> 6</span><span class="w">         </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="linenos"> 7</span><span class="w">         </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="linenos"> 8</span><span class="w">      </span><span class="p">}</span>
<span class="linenos"> 9</span><span class="w">      </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">&gt;</span><span class="w"> </span><span class="n">a</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="linenos">10</span><span class="w">         </span><span class="n">c</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="linenos">11</span><span class="w">         </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">c</span><span class="p">;</span>
<span class="linenos">12</span><span class="w">      </span><span class="p">}</span>
<span class="linenos">13</span><span class="w">   </span><span class="p">}</span>
<span class="linenos">14</span><span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="linenos">15</span><span class="p">}</span>
</pre></div>
</div>
<p>A look at the source code more or less follows the above explanation.</p>
<p>Let’s start by looking at the inner loop at line 5, <code class="docutils literal notranslate"><span class="pre">while</span> <span class="pre">(a</span> <span class="pre">&gt;</span>
<span class="pre">b)</span></code>. In this loop, we are repeatedly subtracting <code class="docutils literal notranslate"><span class="pre">b</span></code> from <code class="docutils literal notranslate"><span class="pre">a</span></code>,
which we know we can do, because <code class="docutils literal notranslate"><span class="pre">a</span></code> started out as being larger
than <code class="docutils literal notranslate"><span class="pre">b</span></code>.  At the end of loop <code class="docutils literal notranslate"><span class="pre">a</span></code> is reduced to either</p>
<ol class="arabic simple">
<li><p><code class="docutils literal notranslate"><span class="pre">b</span></code>, in which case <code class="docutils literal notranslate"><span class="pre">b</span></code> exactly divided the earlier <code class="docutils literal notranslate"><span class="pre">a</span></code>,
and <code class="docutils literal notranslate"><span class="pre">b</span></code> is the GCD, or</p></li>
<li><p>a number less than <code class="docutils literal notranslate"><span class="pre">b</span></code>, namely
<span class="math notranslate nohighlight">\(a \bmod b\)</span> (or in C# terms <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">%</span> <span class="pre">b</span></code>), and the process continues….</p></li>
</ol>
<p>The loop on line 9 is similar to the loop in line 5. For the same
reasons as we already explained, <code class="docutils literal notranslate"><span class="pre">b</span></code> ends up equal to <code class="docutils literal notranslate"><span class="pre">a</span></code>,
which is the GCD, or <code class="docutils literal notranslate"><span class="pre">b</span></code> ends up as
<span class="math notranslate nohighlight">\(b \bmod a\)</span>.</p>
<p>As discussed above, if <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> end up as the same number,
that is the GCD.  On the other hand,
the first GCD algorithm example showed how remainders may need to be to
be calculated over and over.  The outer loop in this version keeps this up
until <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> are reduced to equal
values.  At this point the inner loops would make no further changes,
and the common value is the GCD.</p>
<p>As an exercise to the reader, you may want to consider adding some
<code class="docutils literal notranslate"><span class="pre">Console.WriteLine()</span></code> statements to print the values of <code class="docutils literal notranslate"><span class="pre">a</span></code> and
<code class="docutils literal notranslate"><span class="pre">b</span></code> within each loop, and after both loops have executed. It will
allow you to see in visual terms how this method does its work.</p>
</section>
<section id="gcd-remainder-loop">
<span id="index-1"></span><span id="id2"></span><h2><span class="section-number">6.8.4. </span>GCD Remainder Loop<a class="headerlink" href="#gcd-remainder-loop" title="Permalink to this heading"></a></h2>
<p>There are several ways to code the shorter Euclidean algorithm at the beginning of this
GCD section.  It is a repetitive pattern,
and a loop can be used.  There are two parameters, <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code>, to the gcd,
and they can be successively changed, suggesting a loop.  What is the continuation
condition?  You stop when <code class="docutils literal notranslate"><span class="pre">b</span></code> is 0, so you continue while <code class="docutils literal notranslate"><span class="pre">b</span> <span class="pre">!=</span> <span class="pre">0</span></code>.
The parameters <code class="docutils literal notranslate"><span class="pre">a</span></code> and <code class="docutils literal notranslate"><span class="pre">b</span></code> need to be replaced by <code class="docutils literal notranslate"><span class="pre">b</span></code> and <code class="docutils literal notranslate"><span class="pre">a</span> <span class="pre">%</span> <span class="pre">b</span></code>.
One extra variable needs to be introduced to make this double change work.  The simplest
is to introduce a variable <code class="docutils literal notranslate"><span class="pre">r</span></code> for the remainder.  Check and see for yourself that you
need an extra variable like <code class="docutils literal notranslate"><span class="pre">r</span></code>:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Return the greatest comon divisor of nonnegative numbers,</span>
<span class="c1">/// not both 0.</span>
<span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">GreatestCommonDivisor</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="k">while</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="kt">int</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">      </span><span class="n">a</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">b</span><span class="p">;</span>
<span class="w">      </span><span class="n">b</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">r</span><span class="p">;</span>
<span class="w">   </span><span class="p">}</span>
<span class="w">   </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>More verbose demonstration code,
that prints the progress each time through
loop is in <a class="reference external" href="https://github.com/tychen742/introcs-csharp-examples/blob/master/g_c_d_remainder_loop/g_c_d_remainder_loop.cs">g_c_d_remainder_loop/g_c_d_remainder_loop.cs</a>.</p>
</section>
<section id="preview-recursive-gcd">
<span id="gcd-recursive"></span><span id="index-2"></span><h2><span class="section-number">6.8.5. </span>Preview: Recursive GCD<a class="headerlink" href="#preview-recursive-gcd" title="Permalink to this heading"></a></h2>
<p>The first statement of Euclid’s algorithm said (in C#) when</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="n">gcd</span><span class="p">(</span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">b</span><span class="p">)</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">gcd</span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
</pre></div>
</div>
<p>It is saying the result of the function with one set of parameters is equal to
calling the function with another set of parameters.  If we put this into a
C# function definition, it would mean the instructions for the function say
to <em>call itself</em>.  This is a broadly useful technique called <em>recursion</em>,
where a function calls <em>itself</em> inside its definition.
We don’t expect you to master this
technique immediately but do feel that it is important you at least
<em>hear</em> about it and see its tremendous power:</p>
<div class="highlight-csharp notranslate"><div class="highlight"><pre><span></span><span class="c1">/// Return the greatest comon divisor of nonnegative numbers,</span>
<span class="c1">/// not both 0.</span>
<span class="k">public</span><span class="w"> </span><span class="k">static</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="nf">GreatestCommonDivisor</span><span class="w"> </span><span class="p">(</span><span class="kt">int</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="kt">int</span><span class="w"> </span><span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
<span class="w">   </span><span class="k">if</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="w"> </span><span class="o">==</span><span class="w"> </span><span class="m">0</span><span class="p">)</span><span class="w"> </span><span class="p">{</span><span class="w">                               </span><span class="c1">// base</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="p">;</span><span class="w">                                </span><span class="c1">//   case</span>
<span class="w">   </span><span class="p">}</span><span class="w"> </span><span class="k">else</span><span class="w"> </span><span class="p">{</span>
<span class="w">      </span><span class="k">return</span><span class="w"> </span><span class="nf">GreatestCommonDivisor</span><span class="w"> </span><span class="p">(</span><span class="n">b</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="o">%</span><span class="w"> </span><span class="n">b</span><span class="p">);</span><span class="w"> </span><span class="c1">// recursion</span>
<span class="w">   </span><span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li><p>Recalling our earlier definition, the case <span class="math notranslate nohighlight">\(gcd(a, 0) = a\)</span> is
handled directly by lines commented as “base case”.</p></li>
<li><p>And the case <span class="math notranslate nohighlight">\(gcd(a, b) = gcd(b, a \bmod b)\)</span> is handled by
line with comment “recursion”, with the function calling itself.</p></li>
</ul>
<p>In <a class="reference external" href="https://github.com/tychen742/introcs-csharp-examples/blob/master/g_c_d_euclid_recursive/g_c_d_euclid_recursive.cs">g_c_d_euclid_recursive/g_c_d_euclid_recursive.cs</a>
is a wordier demonstration version that prints to the screen
the progress at each recursive call.</p>
<p>The recursive version of the <code class="docutils literal notranslate"><span class="pre">gcd</span></code> function <em>refers to itself</em>
by <em>calling</em> itself.  Though this seems circular, you can see
from the examples that it works very well.  The important point is that
the calls to the same function are not completely the same:
<em>Successive</em> calls have <em>smaller</em> second numbers, and the second
number eventually reaches 0, and in that case
there is a direct final answer.  Hence the function is not really circular.</p>
<p>This recursive version is a much more direct translation of the original
mathematical algorithm than the looping version!</p>
<p>The general idea of recursion is for a
function to call itself with <em>simpler</em> parameters, until a simple enough place
is reached, where the answer can be directly calculated.</p>
<aside class="footnote-list brackets">
<aside class="footnote brackets" id="gcdbrute" role="note">
<span class="label"><span class="fn-bracket">[</span><a role="doc-backlink" href="#id1">1</a><span class="fn-bracket">]</span></span>
<p>The original brute-force gcd approach always goes through all the integers
between 1 and <code class="docutils literal notranslate"><span class="pre">min(a,</span> <span class="pre">b)</span></code>.  There is a way to stop the first time
the real gcd is reached.  How can you arrange that?</p>
</aside>
</aside>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="userinput.html" class="btn btn-neutral float-left" title="6.7. User Input: UI" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="do-while.html" class="btn btn-neutral float-right" title="6.9. Do-While Loops" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright .
      <span class="lastupdated">Last updated on 22-July-2024 22:22:24.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>