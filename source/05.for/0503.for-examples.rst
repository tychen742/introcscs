
``for`` Statement Examples
==================================

Format Output: Console.Write()
-------------------------------

Thus far all of our ``for`` loops have used a sequence of successive integers.
You can do a quick test in ``csharprepl`` like::

    > for (int i = 1; i < 5; i++)   
     {                          
        Console.WriteLine(i);  
     }   
    1
    2
    3
    4

Now let us make the output neater by using the format string (:ref:`format-strings`) and 
the ``Console.Write()`` method::

    > for (int i = 1; i <= 5; i++)   
      {                          
        Console.WriteLine("{0}, ", i);  
      }   
    1 2 3 4 5

Step in loop header
---------------------

``i++`` is a common pattern and it increments by 1. Also common in the iterator/step section of 
the loop header is using assignment statement to control stepping::

    i = i + k;

or the equivalent short-hand compound assignment operator:: 

   i += k;
   
This means to increment the variable i by k.  

.. index::
   operator; += -= *= /= %=
   single: += operator
   single: -= operator
   single: *= operator
   single: /= operator
   single: %= operator

Most C# binary operations have a similar variation.  For instance
if *op* is ``+``, ``-``, ``*``, ``/`` or ``%``,

    **variable** *op*\ = *expression*
    
means the same as

    **variable** = **variable** op *expression*
    
For example ::

    x *= 5;
    
is the same as  ::

    x = x * 5;
    
.. index::
   format; field width and precision 
   field width formatting
   precision; format
   table formatting
   right justification
   justification; right
   single: { }; format field width and precision

.. _tables:

Tables
----------

Reports commonly include tables, often with successive lines generated by 
a consistent formula. As a simple first table, we can show the square, 
cube, and square root of numbers 1 through 10.  
The Math class has a method ``Sqrt``, so we take the square root with the ``Math.Sqrt``
method. The pattern is consistent, so we can loop easily::

   for ( int n = 1; n <= 10; n++) 
   {
       Console.WriteLine("{0} {1} {2} {3}", n, n*n, n*n*n, Math.Sqrt(n));
   }

The numbers will be there, but the output is not pretty:

.. code-block:: none

    1 1 1 1
    2 4 8 1.4142135623731
    3 9 27 1.73205080756888
    4 16 64 2
    5 25 125 2.23606797749979
    6 36 216 2.44948974278318
    7 49 343 2.64575131106459
    8 64 512 2.82842712474619
    9 81 729 3
    10 100 1000 3.16227766016838


First we might not need all those digits in the square root approximations.
We can replace ``{3}`` by ``{3:F4}`` to just show 4 decimal places.

We can adjust the spacing to make nice
columns by using a further formatting option. The longest entries are all
in the last row, where they take up, 2, 3, 4, and 6 columns (for 3.1623).
Change the format string::

   for ( int n = 1; n <= 10; n++) {
       Console.WriteLine("{0,2} {1,3} {2,4} {3,6:F4}", 
                          n, n*n, n*n*n, Math.Sqrt(n));
   }

and we generate the neater output:

.. code-block:: none

     1   1    1 1.0000
     2   4    8 1.4142
     3   9   27 1.7321
     4  16   64 2.0000
     5  25  125 2.2361
     6  36  216 2.4495
     7  49  343 2.6458
     8  64  512 2.8284
     9  81  729 3.0000
    10 100 1000 3.1623

We are using two new formatting forms: 

   | ``{``\ index\ ``,``\ fieldWidth\ ``}``  and 
   | ``{``\ index\ ``,``\ fieldWidth\ ``:F``\ #\ ``}``   

where index, fieldWidth, and # are replaces by specific literal integers.
The new part with the comma (not colon) and fieldWidth, sets the *minimum*
number of columns used for the substituted string, padding with blanks as needed.


*If the string to be inserted is wider than the fieldWidth,* 
then the *whole* string is inserted, *ignoring* the fieldWidth. For example::

    string s = "stuff";
    Console.WriteLine("123456789");
    Console.WriteLine("{0,9}\n{0,7}\n{0,5}\n{0,3}", s);
    
generates:

.. code-block:: none

    123456789
        stuff
      stuff
    stuff
    stuff

filling 9, 7, and then 5 columns, by padding with 4, 2, and 0 blanks.  
*The last line sticks out past the proposed 3-column fieldWidth.*

One more thing to add to our power table is a heading. We might want:

.. code-block:: none

    n   square    cube    root
    
To make the data line up with the heading titles,
we can expand the columns, with code in example:: csharp

    Console.WriteLine("{0,2}{1,7}{2,5}{3,7}",
                  "n", "square", "cube", "root");
    for ( int n = 1; n <= 10; n++) {
    Console.WriteLine("{0,2}{1,7}{2,5}{3,7:F4}",
                        n, n*n, n*n*n, Math.Sqrt(n));
    }

generating the output:

.. code-block:: none

     n  square    cube    root
     1       1       1  1.0000
     2       4       8  1.4142
     3       9      27  1.7321
     4      16      64  2.0000
     5      25     125  2.2361
     6      36     216  2.4495
     7      49     343  2.6458
     8      64     512  2.8284
     9      81     729  3.0000
    10     100    1000  3.1623

Note how we make sure the columns are consistent in the heading and further rows:  
We used a format string for the headings with the same field widths as
in the body of the table. A separate variation: We also reduced the length
of the format string by putting all the substitution expressions in braces
right beside each other, and generate the space between columns with a 
larger field width.


.. index:: string; reverse
   reverse string example; 

.. _reverse-string-returned:
  
Reversed String Returned
----------------------------

In :ref:`reversed-print-example` we discuss iterating through a string's
indices and characters to print the string reversed.  That might be useful,
but it logically the joining of two separate ideas:  reversing a string and
printing it.  We already know how to print a string as a step.  Now consider 
the first part as its own function:

..  literalinclude:: ../../examples/introcs/reversed_string/reversed_string.cs
    :start-after: chunk
    :end-before: {

To go along with this chapter, we will use a ``for`` loop heading rather 
a ``while`` loop as in :repsrc:`reversed_print/reversed_print.cs`::

    for (int i = s.Length - 1; i >= 0; i--) {   

A more significant difference is that in 
the previous example we immediately printed,
individually, each letter that we wanted.  Now we need to create a single
string, with all the characters, before returning the result.

Let us think of the example in the documentation:  If we start with
``s`` as ``"drab"``, and we go through the letters one at a time in 
reverse order, b a r d, we build up successively:

..  code-block:: none

    b
    ba
    bar
    bard

We need a loop with variables and operations.  The sequence
of reversed letters, ``s[i]``, are the 
last character on the end of each line above.

At least lines after the first are constructed from previous parts,
so, for instance,  ``"bar"``  comes from combining the initial part ``"ba"`` 
with the latest character ``'r'`` (``s[i]``).
We need a name for the initial part.  
I used the name ``rev``.  
Combining with a string is done with the ``+`` operator. 
Then when ``rev`` is ``"ba"`` and ``s[i]`` is ``'r'``, the combination, 
using the variable names, is   ::

    rev + s[i]

We want this in our loop, so we must be able to use 
that expression *each* time through the loop, 
so ``rev``  changes each time through the loop.  In the next iteration ``rev``
is the *result* of the previous expression.  The assignment statement 
to give us the next version of ``rev`` can just be::

     rev = rev + s[i];
     
That gives us the general rule.  Pay attention now to the beginning and end:
The end is simple:  The last value for ``rev`` is the complete reversed string,
so that is what we return.

How do we initialize ``rev``?  You could imagine ``rev`` starting as ``"b"``,
but the the first character that we add is ``'a'``, and we would not be going
through all the characters in our loop.  It is better to go all the way
back to the beginning:  If we use the general form with the first letter in the
reversed sequence, ::

    rev = rev + s[i];

then the result of the initial ``rev`` +  ``'b'`` should just be ``"b"``.  
So what would ``rev`` be?

Remember the empty string:  initialize ``rev`` to be ``""``.

The result is:

..  literalinclude:: ../../examples/introcs/reversed_string/reversed_string.cs
    :start-after: chunk
    :end-before: chunk
    :dedent: 6

We used our new operator ``+=`` to be more concise.

This function and a ``Main`` used to demonstrate it are in `here<
https://introcs.cs.luc.edu/for/forexamples.html#ascii-codes:~:text=reversed_string/reversed_string.cs>`.